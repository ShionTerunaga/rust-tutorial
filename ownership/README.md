GPT 等を用いてまとめたもの

# Rust における所有権とは

プログラムのメモリを安全かつ効率的に管理する仕組み。

# 所有権のルール

1. 値は必ず 1 つの所有者が持つ
   - 複数人の所有者は存在しない
   - 必要がなくなったら自動的に解放する
1. 所有者がスコープから外れたとき、データは解放される
   - スコープから抜けた時点で自動的にメモリを解放される
1. ムーブされる
   - 所有者が新しい変数に代入された場合は新しい変数にムーブされるので元の変数は使えなくなる
   - 元の変数はメモリを自動で解放されるためであると考察する
   - 別の変数に代入されることをムーブという

> [!NOTE]
> スコープとは変数や関数などの名前が有効で使える範囲のことを言う

GPT のサンプル例をそもままコピペ

```rs
{
    let s = String::from("hello"); // sが"hello"を所有
    let t = s; // 所有権がsからtにムーブ
    println!("{}", s); // エラー：sはもう使えない
} // tがスコープを抜けると、"hello"が解放される
```

# 所有権はなぜ必要なのか？

1. 二重解放のバグ
   - 手動でメモリを解放する言語(C や C++)では同じデータを 2 回解放するとエラーが発生する
   - Rust ではデータの所持者は 1 人か
1. メモリリーク
   - 使用が終わったメモリを解放しないとメモリは消費されてしまう
   - スコープを抜けると自動で解放するのでリークの心配はない
1. 不正なメモリアクセス
   - 解放されたデータにアクセスしようとするとクラッシュや不具合が起こってしまう
   - 不正なメモリアクセスをしようとするとコンパイル時に防止してくれる

# 「借用」「参照」の関係

## 借用

- 所有権を移さずに一時的にデータを借りる仕組み
- イミュータブル借用とミュータブル借用がある

```rs
let s = String::from("hello");

// イミュータブル借用
let len = calculate_length(&s); // sの所有権を渡さず、参照だけ渡す
println!("{}", s); // sはまだ使える

fn calculate_length(s: &String) -> usize {
    s.len() // 参照を利用してデータにアクセス
}

// ミュータブル借用
let mut s = String::from("hello");
change(&mut s); // ミュータブル参照で変更可能
println!("{}", s); // "hello world" と表示

fn change(s: &mut String) {
    s.push_str(" world");
}
```

## 参照

- データのアドレスを参照として渡す
- 安全性をコンパイル時にチェック

# Q. 数値型と文字列型で所有権を保持するのとしないのはなぜか

## 1. 数値型は「コピーセマンティクス」が適用される

### メモリの取り扱い

数値型は固定サイズでスタックメモリに格納される。固定サイズのデータは単純にメモリの値をコピーするだけで済むため所有権を持たない

「copy トレイト」が実装されている型(固定サイズの型)は、値がそのままコピーされる

## 2. 文字列型は「所有権」が必要

### メモリの取り扱い

そもそも文字列型は動的にサイズが変わる

1. ヒープ上のデータへのポインタ
1. 文字列の長さ
1. 容量

以上 3 つが格納される

ヒープメモリを正しく管理するためにはどの変数がそのメモリを所有しているかを明確にする必要がある

```rs
let s1 = String::from("hello"); // ヒープ上に文字列を確保
let s2 = s1; // 所有権が`s1`から`s2`に移動
// println!("{}", s1); // エラー: `s1`の所有権が移動している
println!("{}", s2); // 正常に利用可能
```

## 3. 所有権の必要性は「コスト」と「安全性」に基づいて決まる

1. データのサイズ
   - 小さいデータはコピーしてもコストが小さいので不要
   - 大きいデータはコピーするとメモリコストが高くなるため所有権の移動を利用して効率的なメモリ管理を行う
2. メモリの場所
   - 数値型はスタックに格納されスコープを抜けると自動で破棄される
   - 文字列型はヒープを使用するため所有権によって誰がデータを解放する責任を持つかを明確にする必要がある
3. 安全性
   - 二重解放エラー
   - メモリリーク
   - 無効なメモリアクセス
